/* 
 * Copyright (C) 2020 Martin Krcma
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package window;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import javax.imageio.ImageIO;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import logicSimulator.ComputeCore;
import logicSimulator.ExceptionLogger;
import logicSimulator.Tools;
import logicSimulator.WorkSpaceObject;
import logicSimulator.objects.IOPin;
import logicSimulator.projectFile.WorkSpace;
import logicSimulator.ui.Colors;
import logicSimulator.ui.SystemResources;

/**
 *
 * @author Martin
 */
public class Grapher extends javax.swing.JFrame {

    private final GrapherPanel grapherPanel;

    private final ComputeCore computeCore;
    private final WorkSpace workspace;

    private final ActionListener samplingAction;

    /**
     * Creates new form Grapher
     *
     * @param work WorkSpace
     * @param computeCore ComputeCore
     */
    public Grapher(WorkSpace work, ComputeCore computeCore) {
        initComponents();
        this.setLocationRelativeTo(null);

        this.grapherPanel = new GrapherPanel(this.jScrollPane1);
        this.jScrollPane1.setViewportView(this.grapherPanel);

        this.workspace = work;
        this.computeCore = computeCore;

        this.samplingAction = new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                grapherPanel.readCurrentValues(workspace);
            }
        };
        computeCore.addOnTickListener(this.samplingAction);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButtonSaveImg = new javax.swing.JButton();
        jButtonClearScreen = new javax.swing.JButton();
        jButtonRun = new javax.swing.JButton();
        jButtonStepSize = new javax.swing.JButton();
        jButtonAddProbe = new javax.swing.JButton();
        jButtonRemoveProbe = new javax.swing.JButton();
        jButtonOnTop = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jButtonAutoScroll = new javax.swing.JButton();
        jButtonRR = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Grapher");
        setIconImage(SystemResources.ICON);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jButtonSaveImg.setText("Sava Image");
        jButtonSaveImg.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSaveImgActionPerformed(evt);
            }
        });

        jButtonClearScreen.setText("Clear Screen");
        jButtonClearScreen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearScreenActionPerformed(evt);
            }
        });

        jButtonRun.setText("Run");
        jButtonRun.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonRunActionPerformed(evt);
            }
        });

        jButtonStepSize.setText("Step size");
        jButtonStepSize.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonStepSizeActionPerformed(evt);
            }
        });

        jButtonAddProbe.setText("Add Probe");
        jButtonAddProbe.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAddProbeActionPerformed(evt);
            }
        });

        jButtonRemoveProbe.setText("Remove Probe");
        jButtonRemoveProbe.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonRemoveProbeActionPerformed(evt);
            }
        });

        jButtonOnTop.setText("On top");
        jButtonOnTop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonOnTopActionPerformed(evt);
            }
        });

        jButtonAutoScroll.setText("Auto Scroll");
        jButtonAutoScroll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAutoScrollActionPerformed(evt);
            }
        });

        jButtonRR.setText("Reduce Redundancy");
        jButtonRR.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonRRActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButtonSaveImg, javax.swing.GroupLayout.DEFAULT_SIZE, 105, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonClearScreen, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonRemoveProbe, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonAddProbe, javax.swing.GroupLayout.DEFAULT_SIZE, 114, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonStepSize, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButtonOnTop, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonRR, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonAutoScroll, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonRun, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonSaveImg)
                    .addComponent(jButtonClearScreen)
                    .addComponent(jButtonRemoveProbe)
                    .addComponent(jButtonAddProbe)
                    .addComponent(jButtonStepSize))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 351, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonOnTop)
                    .addComponent(jButtonAutoScroll)
                    .addComponent(jButtonRun)
                    .addComponent(jButtonRR))
                .addGap(5, 5, 5))
        );

        this.jButtonRun.setBackground(Color.LIGHT_GRAY);
        this.jButtonOnTop.setBackground(Color.LIGHT_GRAY);
        this.jButtonAutoScroll.setBackground(Color.LIGHT_GRAY);
        this.jButtonRR.setBackground(Color.LIGHT_GRAY);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonAddProbeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAddProbeActionPerformed
        //hide this grapher
        Grapher tREF = this;
        tREF.setVisible(false);

        //add new probe
        JPanel workPanel = (JPanel) this.workspace.getHandler();

        workPanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                //find nerest point from the position of mouse click
                IOPin min = null;
                double minDist = Double.MAX_VALUE, dist;
                for (WorkSpaceObject obj : workspace.getObjects()) {
                    if (obj != null) {
                        for (IOPin pin : obj.getPins()) {
                            //distance between iopin and cursor
                            dist = Tools.dist(Tools.add(pin.getPosition(), obj.getPosition()),
                                    e.getPoint());
                            if (minDist > dist) {
                                minDist = dist;
                                min = pin;
                            }
                        }
                    }
                }

                //set nerest point as probe and add it to the probe list in grapher
                String pName = JOptionPane.showInputDialog(tREF, "Write name of this probe", "Probe name", JOptionPane.QUESTION_MESSAGE);
                grapherPanel.getProbes().add(new Probe(pName, min));

                //refresh channels and repaint graph
                grapherPanel.refreshChannels();
                grapherPanel.repaint();

                workPanel.removeMouseListener(this);
                tREF.setVisible(true);
            }
        });
    }//GEN-LAST:event_jButtonAddProbeActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        this.computeCore.removeOnTickListener(this.samplingAction);
    }//GEN-LAST:event_formWindowClosing

    private void jButtonOnTopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonOnTopActionPerformed
        if (this.isAlwaysOnTop()) {
            this.setAlwaysOnTop(false);
            this.jButtonOnTop.setBackground(Color.LIGHT_GRAY);
        } else {
            this.setAlwaysOnTop(true);
            this.jButtonOnTop.setBackground(Color.GREEN);
        }
    }//GEN-LAST:event_jButtonOnTopActionPerformed

    private void jButtonClearScreenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearScreenActionPerformed
        //clear screen
        this.grapherPanel.clearData();
        this.grapherPanel.repaint();
    }//GEN-LAST:event_jButtonClearScreenActionPerformed

    private void jButtonRemoveProbeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRemoveProbeActionPerformed
        //load all probe names
        String[] probeNames = new String[this.grapherPanel.probes.size()];
        for (int i = 0; i < this.grapherPanel.probes.size(); ++i) {
            probeNames[i] = this.grapherPanel.probes.get(i).name;
        }

        //show dialog
        JComboBox comboBox = new JComboBox(probeNames);
        JOptionPane.showMessageDialog(
                this.grapherPanel,
                new Object[]{"Choose one probe that you want remove.", comboBox},
                "Remove probe",
                JOptionPane.QUESTION_MESSAGE
        );

        ///remove selected probe
        int index = comboBox.getSelectedIndex();
        if (index != -1) {
            this.grapherPanel.probes.remove(index);
        }

        //refresh grapher
        this.grapherPanel.refreshChannels();
        this.grapherPanel.repaint();
    }//GEN-LAST:event_jButtonRemoveProbeActionPerformed

    private void jButtonRunActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRunActionPerformed
        //run / stop
        this.grapherPanel.run = !this.grapherPanel.run;
        this.jButtonRun.setBackground(this.grapherPanel.run ? Color.GREEN : Color.LIGHT_GRAY);
        this.jButtonRun.setText(this.grapherPanel.run ? "Stop" : "Run");
    }//GEN-LAST:event_jButtonRunActionPerformed

    private void jButtonAutoScrollActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonAutoScrollActionPerformed
        this.grapherPanel.autoScroll = !this.grapherPanel.autoScroll;
        this.jButtonAutoScroll.setBackground(this.grapherPanel.autoScroll ? Color.GREEN : Color.LIGHT_GRAY);
    }//GEN-LAST:event_jButtonAutoScrollActionPerformed

    private void jButtonRRActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRRActionPerformed
        this.grapherPanel.RR = !this.grapherPanel.RR;
        this.jButtonRR.setBackground(this.grapherPanel.RR ? Color.GREEN : Color.LIGHT_GRAY);
    }//GEN-LAST:event_jButtonRRActionPerformed

    private void jButtonStepSizeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonStepSizeActionPerformed
        JTextField textField = new JTextField(this.grapherPanel.step + "");

        JOptionPane.showMessageDialog(
                this,
                new Object[]{"Enter new size of step (px)", textField},
                "Step size",
                JOptionPane.QUESTION_MESSAGE
        );

        try {
            this.grapherPanel.step = Float.parseFloat(textField.getText());
            this.grapherPanel.repaint();
        } catch (NumberFormatException ex) {
        }
    }//GEN-LAST:event_jButtonStepSizeActionPerformed

    private void jButtonSaveImgActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSaveImgActionPerformed
        //create image and render grapher to this image
        BufferedImage img = new BufferedImage(
                this.grapherPanel.getWidth(),
                this.grapherPanel.getHeight(),
                BufferedImage.TYPE_INT_ARGB
        );
        Graphics g = img.createGraphics();

        //set offset to m
        int hVal = this.grapherPanel.scrollPane.getHorizontalScrollBar().getValue();
        int vVal = this.grapherPanel.scrollPane.getVerticalScrollBar().getValue();
        this.grapherPanel.scrollPane.getHorizontalScrollBar().setValue(0);
        this.grapherPanel.scrollPane.getVerticalScrollBar().setValue(0);

        //render
        this.grapherPanel.render(g);

        this.grapherPanel.scrollPane.getHorizontalScrollBar().setValue(hVal);
        this.grapherPanel.scrollPane.getVerticalScrollBar().setValue(vVal);

        //choose path and save image
        JFileChooser chooser = new JFileChooser();
        if (chooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {

            //add fily format "png" (only if its needed)
            String path = chooser.getSelectedFile().getAbsolutePath();
            path += path.endsWith(".png") ? "" : ".png";

            try {
                ImageIO.write(img, "png", new File(path));
            } catch (IOException ex) {
                ExceptionLogger.getInstance().logException(ex);
            }
        }

    }//GEN-LAST:event_jButtonSaveImgActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonAddProbe;
    private javax.swing.JButton jButtonAutoScroll;
    private javax.swing.JButton jButtonClearScreen;
    private javax.swing.JButton jButtonOnTop;
    private javax.swing.JButton jButtonRR;
    private javax.swing.JButton jButtonRemoveProbe;
    private javax.swing.JButton jButtonRun;
    private javax.swing.JButton jButtonSaveImg;
    private javax.swing.JButton jButtonStepSize;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables

    private class Probe {

        public final IOPin pin;
        public final String name;

        public Probe(String name, IOPin pin) {
            this.pin = pin;
            this.name = name;
        }
    }

    private class GrapherPanel extends JPanel {

        //list with current values on pins
        private final LinkedList<boolean[]> data = new LinkedList<>();

        //probes
        private final List<Probe> probes = new ArrayList<>();

        //input channel count
        private int channelCount = 0;

        //step in graph between two samples (in px)
        public float step = 10;

        public boolean run = false;

        public boolean autoScroll = true;

        //redundancy reduction
        public boolean RR = false;

        //scroll panel for this component
        private final JScrollPane scrollPane;

        //maximum width of probe name from the list
        private int maxProbeNameWidth = -1;

        public GrapherPanel(JScrollPane scrollPane) {
            this.scrollPane = scrollPane;
        }

        /**
         * Get all probes
         *
         * @return List<IOPin>
         */
        public List<Probe> getProbes() {
            return this.probes;
        }

        /**
         * Clear grapher data
         */
        public void clearData() {
            this.data.clear();
        }

        private void computeMaxProbeNameWidth(Graphics2D g2) {
            try {
                int max = g2.getFontMetrics().stringWidth("bit 00");    //default bit index (in each line)
                for (Probe probe : this.probes) {
                    max = Math.max(max, g2.getFontMetrics().stringWidth(probe.name));
                }
                this.maxProbeNameWidth = max + 10;
            } catch (Exception ex) {
            }
        }

        //for ignor
        private boolean[] lastSample;
        private int cnt_break = 0;

        /**
         * Read current values from the workspace
         *
         * @param workspace WorkSpace
         */
        public void readCurrentValues(WorkSpace workspace) {
            if (!this.run) {
                return;
            }

            //load new values
            int index = 0;
            boolean[] sample = new boolean[this.channelCount];
            for (Probe probe : this.probes) {
                for (boolean bit : probe.pin.getValue()) {
                    sample[index++] = bit;
                }
            }

            //if current and last sample buffers are same than must wast that
            if (this.RR && this.lastSample != null) {
                if (sample.length == this.lastSample.length) {
                    int cnt = 0;
                    for (int i = 0; i < sample.length; ++i) {
                        if (sample[i] != this.lastSample[i]) {
                            this.cnt_break = 0;
                            break;
                        }
                        ++cnt;
                    }
                    if (cnt == sample.length) {
                        if (this.cnt_break > 10) {
                            return;
                        } else {
                            ++this.cnt_break;
                        }
                    }
                }
            }

            //store current sample buffer
            if (this.RR) {
                this.lastSample = sample;
            }

            //add current sample to the data array of grapher
            this.data.add(sample);

            //max lenght of history is 5x width
            if (this.data.size() * this.step > this.scrollPane.getWidth() * 5) {
                this.data.removeFirst();
            }

            //resize
            super.setPreferredSize(new Dimension((int) (this.step * this.data.size() + 25),
                    this.channelCount * 80 + 25));
            super.revalidate();
            //scroll to right
            if (this.autoScroll) {
                this.scrollPane.getHorizontalScrollBar().setValue(
                        this.scrollPane.getHorizontalScrollBar().getMaximum());
            }

            super.repaint();
        }

        /**
         * Count number of input channels, clear displayed data and resize graph
         */
        public void refreshChannels() {
            //count channelCount
            this.channelCount = 0;
            this.probes.stream().forEach((probe) -> {
                this.channelCount += probe.pin.getValue().length;
            });

            this.maxProbeNameWidth = -1;

            //reset values
            this.data.clear();

            //resize
            super.setPreferredSize(new Dimension((int) (this.step * this.data.size() + 25),
                    this.channelCount * 80 + 25));
            super.revalidate();
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            render(g);
        }

        public void render(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            Tools.setHighQuality(g2);

            //draw background
            g2.setColor(Colors.GR_BACKGROUND);
            g2.fillRect(0, 0, super.getWidth(), super.getHeight());

            //compute max probe name width
            if (this.maxProbeNameWidth == -1) {
                computeMaxProbeNameWidth(g2);
            }

            //draw axes
            g2.setStroke(new BasicStroke(2));
            g2.setColor(Colors.GR_AXES);
            g2.drawLine(
                    this.maxProbeNameWidth + this.scrollPane.getHorizontalScrollBar().getValue(),
                    5,
                    this.maxProbeNameWidth + this.scrollPane.getHorizontalScrollBar().getValue(),
                    super.getHeight() - 5
            );
            g2.setStroke(new BasicStroke(1));
            for (int i = 0; i < this.channelCount; ++i) {
                g2.drawLine(
                        5,
                        (i + 1) * 80,
                        super.getWidth() - 5,
                        (i + 1) * 80
                );
            }

            //draw time line
            g2.setStroke(new BasicStroke(1, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND, 2f, new float[]{2f, 7f}, 0f));
            g2.setColor(Color.LIGHT_GRAY);
            float x = this.maxProbeNameWidth;
            do {
                g2.drawLine((int) x, 5 + this.scrollPane.getVerticalScrollBar().getValue(),
                        (int) x, this.scrollPane.getHeight() - 5 + this.scrollPane.getVerticalScrollBar().getValue());
            } while ((x += this.step * 5) < super.getWidth());

            //draw data
            g2.setColor(Colors.GR_GRAPHLINE);
            g2.setStroke(new BasicStroke(1));
            boolean[] sample, lastSample = null;
            for (int i = 0; i < this.data.size(); ++i) {
                sample = this.data.get(i);

                for (int j = 0; j < sample.length; ++j) {
                    if (lastSample != null) {
                        g2.drawLine(
                                (int) (this.maxProbeNameWidth + i * this.step),
                                j * 80 + 10 + (lastSample[j] ? 0 : 60),
                                (int) (this.maxProbeNameWidth + (i + 1) * this.step),
                                j * 80 + 10 + (sample[j] ? 0 : 60)
                        );
                    }
                }

                lastSample = sample;
            }

            g2.setColor(Colors.GR_BACKGROUND);
            g2.fillRect(
                    this.scrollPane.getHorizontalScrollBar().getValue(),
                    this.scrollPane.getVerticalScrollBar().getValue(),
                    this.maxProbeNameWidth,
                    this.scrollPane.getHeight()
            );

            //draw probe names
            g2.setColor(Colors.GR_GRAPHLINE);
            int channelIndex = 0, probeBits;
            for (int i = 0; i < this.probes.size(); ++i) {
                probeBits = this.probes.get(i).pin.getValue().length;
                for (int j = 0; j < probeBits; ++j) {
                    //draw name of probe
                    g2.drawString(this.probes.get(i).name,
                            5 + this.scrollPane.getHorizontalScrollBar().getValue(),
                            35 + channelIndex * 80);
                    //draw bit index
                    g2.drawString("bit " + j,
                            5 + this.scrollPane.getHorizontalScrollBar().getValue(),
                            50 + channelIndex * 80);
                    //increment channel index
                    ++channelIndex;
                }
            }
        }

    }

}
